using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace XnbSerialization.Generator;

/// <summary>
/// A sample source generator that creates a custom report based on class properties. The target class should be annotated with the 'Generators.ReportAttribute' attribute.
/// When using the source code as a baseline, an incremental source generator is preferable because it reduces the performance overhead.
/// </summary>
[Generator]
public class XnbClassGenerator : IIncrementalGenerator
{
    private const string NAMESPACE = "Xnb.Reader.ContentReader";
    private const string ATTRIBUTE_NAME = "ClassReaderAttribute";

    private const string ATTRIBUTE_SOURCE_CODE = $$"""
// <auto-generated/>

namespace {{NAMESPACE}}
{
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public class {{ATTRIBUTE_NAME}} : System.Attribute;
}
""";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add the marker attribute to the compilation.
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
                                                     "ClassReaderAttribute.g.cs",
                                                     SourceText.From(ATTRIBUTE_SOURCE_CODE, Encoding.UTF8)));

        // Filter classes annotated with the [ClassReader] attribute. Only filtered Syntax Nodes can trigger code generation.
        var provider = context.SyntaxProvider
                              .CreateSyntaxProvider(static (s, _) => s is ClassDeclarationSyntax or RecordDeclarationSyntax,
                                                    static (ctx, _) => GetClassDeclarationForSourceGen(ctx))
                              .Where(static t => t.reportAttributeFound).Select((t, _) => t.Item1);

        // Generate the source code.
        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
                                     static (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
    }

    /// <summary>
    /// Checks whether the Node is annotated with the [ClassReader] attribute and maps syntax context to the specific node type (ClassDeclarationSyntax or RecordDeclarationSyntax).
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>The specific cast and whether the attribute was found.</returns>
    private static (TypeDeclarationSyntax, bool reportAttributeFound) GetClassDeclarationForSourceGen(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (TypeDeclarationSyntax)context.Node;

        // Go through all attributes of the class.
        foreach (var attributeSyntax in classDeclarationSyntax.AttributeLists.SelectMany(attributeListSyntax => attributeListSyntax.Attributes))
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                continue; // if we can't get the symbol, ignore it

            string attributeName = attributeSymbol.ContainingType.ToDisplayString();

            // Check the full name of the [ClassReader] attribute.
            if (attributeName == $"{NAMESPACE}.{ATTRIBUTE_NAME}") return (classDeclarationSyntax, true);
        }

        return (classDeclarationSyntax, false);
    }

    /// <summary>
    /// Generate code action.
    /// It will be executed on specific nodes (ClassDeclarationSyntax annotated with the [ClassReader] attribute) changed by the user.
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
    /// <param name="classDeclarations">Nodes annotated with the [ClassReader] attribute that trigger the generate action.</param>
    private static void GenerateCode(SourceProductionContext context, Compilation compilation,
                                     ImmutableArray<TypeDeclarationSyntax> classDeclarations)
    {
        StringBuilder readerRegisters = new();
        StringBuilder jsonRegisters = new();
        StringBuilder allNamespaces = new();
        // Go through all filtered class declarations.
        foreach (var classDeclarationSyntax in classDeclarations)
        {
            // We need to get semantic model of the class to retrieve metadata.
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            // Symbols allow us to get the compile-time information.
            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol) continue;

            string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            allNamespaces.AppendFormat("using {0};", namespaceName).AppendLine();
            
            // 'Identifier' means the token of the node. Get class name from the syntax node.
            string className = classDeclarationSyntax.Identifier.Text;

            readerRegisters.AppendLine().AppendFormat("        Register(new {0}Reader());", className);
            jsonRegisters.AppendLine().AppendFormat("[JsonSerializable(typeof({0}))]", className);

            var props = classSymbol.GetMembers().OfType<IPropertySymbol>();
            if (classDeclarationSyntax is RecordDeclarationSyntax)
            {
                props = props.Skip(1);
            }
            
            var properties = props.ToArray();
            
            // Go through all class members with a particular type (property) to generate method lines.
            var readerMethodBody = properties.Select(static p => $"        var {ToCamelCase(p.Name)} = ReaderResolver.Read<{p.Type.ToDisplayString()}>(buffer);");
            var writerMethodBody =
                properties.Select(static p => $"        ReaderResolver.Write(buffer, content.{p.Name});");

            StringBuilder constructObject = new($"        return new {className}");

            if (classDeclarationSyntax is ClassDeclarationSyntax)
            {
                constructObject.Append("() { ");

                foreach (var p in properties)
                {
                    constructObject.AppendFormat("{0} = {1}, ", p.Name, ToCamelCase(p.Name));
                }

                constructObject.Append(" };");
            }
            else
            {
                constructObject.Append("(")
                               .Append(string.Join(", ", properties.Select(p => ToCamelCase(p.Name))))
                               .Append(");");
            }

// Build up the source code
            string code = $$"""
// <auto-generated/>

using System;
using System.Collections.Generic;
using {{namespaceName}};

namespace {{NAMESPACE}};

public class {{className}}Reader: BaseReader<{{className}}>
{
    public override {{className}} Read(BinaryReader buffer)
    {
{{string.Join("\n", readerMethodBody)}}
{{constructObject}}
    }

    public override void Write(BinaryWriter buffer, {{className}} content)
    {
{{string.Join("\n", writerMethodBody)}}
    }
}

""";

            // Add the source code to the compilation.
            context.AddSource($"{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
        // Register all readers
        string registerCode = $$"""
// <auto-generated/>

using System;
using System.Collections.Generic;

namespace {{NAMESPACE}};

public static partial class ReaderResolver
{
    static partial void RegisterClassReaders()
    {{{readerRegisters}}
    }
}

""";
        context.AddSource("ReaderResolver.Class.g.cs", SourceText.From(registerCode, Encoding.UTF8));
        return;

        static string ToCamelCase(string str) => char.ToLowerInvariant(str[0]) + str.Substring(1);
    }
}
